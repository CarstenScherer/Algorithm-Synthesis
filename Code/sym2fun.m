%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% File     : symdfun2funhan.m                                             %
%                                                                         %
% Author   : Tobias Holicki                                               %
% Version  : 01                                                           %
% Date     : 27.09.2022                
%                                   
% Slighty modified: CWS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This function takes as input a symbolic function fs for example as
% generated by
%    syms x y
%    fs(x, y) = 100*(y - x^2)^2 + (1 - x)^2;
% and returns function handles f, g, H corresponding to the function fs,
% its gradient and its Hessian. Any of these functions can take a matrix X
% as input where each column is a data point at which the corresponding 
% function is evaluated. For the above example and 
%    X = [1, 2, 3; 1, 0, 1]
% we have
%    f(X) = [0, 1601, 6404]
%    g(X) = [0, 3202,  9604; ...
%            0, -800, -1600]
% For the Hessian the output is a matrix for a singla data point and a cell
% of matrices for more than one data points.
%
function s = sym2fun(fs,p)
% Sanity check
    arguments
        fs (1, 1) {mustBeA(fs, 'symfun')}
        p
    end

args = argnames(fs); % Names of arguments involved in the symbolic 
                     % function fs

s=p;
% Gradient and Hessian as symbolic functions
s.fs = fs;
s.gs = gradient(fs, args);
s.Hs = hessian(fs, args);
s.gsn=norm(s.gs);

% Conversion of symbolic function to function handles. These function can 
% take a matrix X as input where each column of X is one data point at
% which the respective function is evaluated. 
s.f  = matlabFunction(fs, 'vars', {args.'});
s.g  = matlabFunction(s.gs, 'vars', {args.'});
s.gn  = matlabFunction(s.gsn, 'vars', {args.'});
Hm = matlabFunction(s.Hs, 'vars', {args.'});

s.H  = @Hc;
s.Hev= @Hev;


% For the Hessian we return a cell of corresonding Hessian matrices
% evaluated at the given data points if more than one data point is
% involved.
    function erg = Hc(x)
        num_samples = size(x, 2);
        if num_samples == 1
            erg = Hm(x);
        else
            erg = cell(1, num_samples);
            for i = 1 : num_samples
                erg{i} = Hm(x(:, i));
            end
        end % if
    end % function Hc

    function ev = Hev(x)
        num_samples = size(x, 2);
        for i = 1 : num_samples
            ev(:,i)=eig(Hm(x(:, i)));
        end
    end % function Hev

end
